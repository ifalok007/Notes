---> Debugging Skills
	A lot of people focus on tools and languages and frameworks for debugging but there are some meta-techniques which, if you practice, are really helpful in fixing bugs in lesser amount of time.
	Languages may come and go and so will IDEs and debuggers, but the ability to discern under which rock your bug is hiding is one that will stay with you forever.
	But one can not deny the amount of ease IDEs and tools add to our debugging.Knowledge of IDE debuggers is very important IMHO.
	"IF YOU HAVE BEEN LOOKING FOR A BUG FOR A RELATIVELY LONG TIME AND CAN'T FIND IT THEN YOU ARE LOOKING IN WRONG PLACE."
	Here are a few way shared by various developpers using which one can improve his/her debugging :
	1.Be disciplined. Debugging is a process, said one developer, not a series of random events. Don't randomly tweak knobs; follow the code's execution process. Just like fixing a lawnmower, he said. Does part A get the input it needs? How about the output? If that's OK, move on.
	
	2.To improve your skills, debug other people's code rather than your own. It will be easier to see the faults in the other person's assumptions than it is to see your own. You might do this as part of a cross-peer code review and cross-peer debugging. You will develop the ability to recognize the common causes of defects more quickly, promised one developer, and teach you to recognize (and abandon) your own bad development practices.
	
	3.Pretend you're the compiler. Find and correct as many errors as you can before pressing the Compile button. While most modern IDEs include integrated debuggers (like Visual Studio's Intellisense), you'll learn less from their automation than you will from consciously examining the process. (The same way you'll never learn to spell correctly by relying on a spell checker to do all the work.)
	
	4.Learn to fix bugs as early in the development process as you can. That might mean something formalized, such as test-driven development. That also means devoting time to debugging your design instead of barreling into coding.
	
	5.Debugging is easiest when you can hold the whole system in your head. Don't make the mistake of focusing in on only one part of an application. Pay attention to the interrelationships between modules. Read the code at multiple levels of abstraction, advised one programmer. "Finding the bug is the hardest part, and it takes clear understanding of what multiple pieces of the code are doing," she said.
	
	6.(my favoruit) Part of the same bit of advice, I think, is someone else's suggestion: gain a good understanding of the system one level down from what you are working on. "If you are debugging a system level C program, it helps to know some assembly and something about the OS," explained a system software lead engineer. "If you are debugging a J2EE app, it helps to know something about Java threads, RMI and GC." In many cases, he pointed out, error messages come from that one-level-down. "If you can understand what that means, it will help you figure out what is going wrong at your level of abstraction," he explained.

---> Rule Techonology :
Drools, Rule Engine..

---> Spring AOP :
	Cross Curring Concerns 
		The majority of the aplications we design will contain common functionality that spans layers and tiers.This functionality typically supports operations such authentication, authorization, caching, communication, exception management, Logging, instrumentation and validation.Such functionlaity is generally described as cross-cutting concern because it affects the entire application and should be centralized in one location in the code where possible.For example, If code that generates log entries and writes to the application logs is scattered throughout your layers and tiers, and the requirement related to these concerns change (such as logging to different location), you may have to update the relevant code throughout the entire system.Instead, If you centralize the logging code, you can chnage the behaviour bychanging the code in the just one location.
		
		In Spring a pointcut expression is used to determine whether advice needs to be executed or not 
			for ex, 	
				@PointCut("within(com.journaldev.spring.service.*)")
			sp there  are chances that these advices may get applied to some beans where its not intended.
			Thats why we create a custome annotation and annotae the method where we want the advice to be applied.
				pulic @interface Loggable{
				
				}
				
				@Aspect 
				public class EmployeeAnnotationAspect{
					@Before("@annotation(com.journaldev.spring.aspect.Loggable)")
					public void myAdvice(){
						System.out.println("executing my advice");
					}
				}
	
---> Spring fundamentals :



---> SQL replace NULL with empty String
	There are two ways to replace NULL with blank values in SQL Server, function ISNULL() and COALESCE()

---> Unable to install a breakpoint in (Eclipse debug mode error):
	configure build path- java compiler- add line number attribute
	
--->Checklist:
	1. Angular clean code 
	2. An Angular JS playbook
	3. Mockups (Ln bulletin)
	4. Spring boot 
	5. Drools (low priority)
	6. uib-modal dissection
	7. font-awesome
	8. token based vs cookie based authentication ,JSON Web Tokens (JWT) https://auth0.com/blog/cookies-vs-tokens-definitive-guide/
	9. NgModel Controller
	10. Configurable directives using Providers, by supplying configuration options before directive is instantiated
	11. Decorators to decorate services before use
CK:
	1. Angular UI router States
	2. Directives 
	3.	

---> Organizing multi-module maven project in eclipse project explorer (show child modules as child nodes):
	windows->Preferences-> Maven->Hide foders of physically nested modules and then re-import
				or 
	configure working sets 
	
---> <pluginManagement> vs <plugin> maven :
	Plugin configuration can be configured to be inherited by child POMs( or child modules) by using <pluginManagement/>.Plugin Configration added inside <pluginManagement/> doesn't apply to the POM (or project) it is defined in rather its intended for child POMs or projects.
	from child POMs you need to reference this parent plugin configuration to inherit the configuration, moreover child plugins can override parent pluginManagement definintion.
		
---> Combining Configuration Styles in Using Spring 4 (xml+java)
		http://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch06.html
		
---> Advantage and disadvantages of using XML config vs annotation
	XML configuration can be shared amaong different programming environments but not annotations
	annotations are attached to artifact they describe, thats a 'pro' point of annaotation
	
---> Unit testing Private methods:
	1.#Using Bytecode manipulator framework like PowerMock with mockito#
	2.By refactoring by changing private access modifier to default 
		as test classes are placed in same package yet in different folder(src/main/test)
			src/main/java
				com.infosys.fingerprintscanner.scanner
			src/test/java
				com.infosys.fingerprintscanner.scanner
				
---> Differential backup fo database in SqlServer
	A differential backup is based on the most recent, previous full data backup. A differential backup captures only the data that has changed since that full backup.
	
---> Precision vs Scale
	Numeric precision refers to the maximum number of digits that are present in the number.

	ie 1234567.89 has a precision of 9

	Numeric scale refers to the maximum number of decimal places

	ie 123456.789 has a scale of 3

	Thus the maximum allowed value for decimal(5,2) is 999.99
	
---> Running tests for a particular class mvn command
	mvn -Dtest=TstClassName test
	mvn -Dtest=TestClassName#testMethod# test

---> Spring Annotayions for configuration :
	@Configuration : 
	@EnableAutoConfiguration : 
		configures application based on the classes present on class path such as if Spring data JPA present of the class path the spring will register a entity manager factory bean if the user has not done so. As user's configurations override auto configurations. Any configuration added by this annotation which is not relevant can be exculeded using exclude property on the annotations	
			@EnableAutoConfiguration(exclude = { MetricFilterAutoConfiguration.class, MetricRepositoryAutoConfiguration.class })
					which excludes #actuator# configuration ;
					#Actuator# endpoints allow you to monitor and interact with your application. Spring Boot includes a number of built-in endpoints and you can also add your own. For example the health endpoint provides basic application health information.
	@SpringBootApplication :
		
--->HashMap(bucket) vs TreeMap(Red-black tree) vs LinkedHashMap(double bucket) :

	All three classes implement the Map interface and offer mostly the same functionality. The most important difference is the order in which iteration through the entries will happen:

	HashMap makes absolutely no guarantees about the iteration order. It can (and will) even change completely when new elements are added.
	TreeMap will iterate according to the "natural ordering" of the keys according to their compareTo() method (or an externally supplied Comparator). Additionally, it implements the SortedMap interface, which contains methods that depend on this sort order.
	LinkedHashMap will iterate in the order in which the entries were put into the map
			╔══════════════╦═════════════════════╦═══════════════════╦═════════════════════╗
			║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap   ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║  no guarantee order ║ sorted according  ║                     ║
			║   Order      ║ will remain constant║ to the natural    ║    insertion-order  ║
			║              ║      over time      ║    ordering       ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║  Get/put     ║                     ║                   ║                     ║
			║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)        ║
			║ containsKey  ║                     ║                   ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║                     ║   NavigableMap    ║                     ║
			║  Interfaces  ║         Map         ║       Map         ║         Map         ║
			║              ║                     ║    SortedMap      ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║                     ║                   ║                     ║
			║     Null     ║       allowed       ║    only values    ║       allowed       ║
			║ values/keys  ║                     ║                   ║                     ║
			╠══════════════╬═════════════════════╩═══════════════════╩═════════════════════╣
			║              ║   Fail-fast behavior of an iterator cannot be guaranteed      ║
			║   Fail-fast  ║ impossible to make any hard guarantees in the presence of     ║
			║   behavior   ║           unsynchronized concurrent modification              ║
			╠══════════════╬═════════════════════╦═══════════════════╦═════════════════════╣
			║              ║                     ║                   ║                     ║
			║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked    ║
			║              ║                     ║                   ║       buckets       ║
			╠══════════════╬═════════════════════╩═══════════════════╩═════════════════════╣
			║      Is      ║                                                               ║
			║ synchronized ║              implementation is not synchronized               ║
			╚══════════════╩═══════════════════════════════════════════════════════════════╝
			workFlowActionMap is stored using LinkedHashMap in current project.
--->Doubly linked list:
	in singly linked list nodes have pointer to next node, so its not feasible to traverse a singly linked list backwards . in Doubly lined list nodes have pointers to next and previous both nodes hence backward traversing is possible. LinkedHashMap uses doubly linked list with bucket data structure.
--->AVL trees and Red Black Trees :
	in non-hight balanced Binary search tree the time complexity of searching is O(h) where is h is Height of the tree, if the hight of binary search tree is balanced with each insertion and removal of the nodes fro the BST then time complexity becomes O(log n) where n is number of nodes.AVL trees are a kind BSTs.AVL trees and Red-Black trees are hight balanced trees.In AVL trees the Balance Facoctor must not exceed 1.Balance Factor is Height of LeftSubtree - height of Right Subtree.If after any insertion/removal of a node from AVL tree makes Balance factor to 1 then the tree/subtree is rotated to make it hight balanced.
	
---> Binary Heap:
	A Binary is a complete tree (in which all levels are completely filled) except for last level and the last level has all the keys as lef as possible.This property of Binary heap make them suitable to pe stored in array.A bianry Heap is either min-heap or max-heap.
	Max-heap parent key is greater than both child keys and this is true for recursively all its subtrees and same goes with Min-heap.
	Binary Heap are very usefull in implementing efficient prority queues which are used for job scheduling processes in OS.Priority queues are also used in Dijkastr's and Prim's Graph algos.
---> Preventing CSS inheritance :
	in CSS there is not parent selector so far so you have to use child selctors to override styles of parent element.
	Or you can write selectors with high specificity so that styling does't cascade to unwanted elements.
	eventually Cascading is sort of the whole point of Cascading Style Sheets, hence the name.
---> hibernate Revisit :
	proxy objects for lazy loading 
	how JDBC does transacton management ? Hibernate makes Transaction Management very easy for developer.
		things involved in JDBC transaction and rollback(setting autoCommit to false before executing JDBC queries and then calling commit() manually after query executions, setting savePoints to rollback transaction to a specific state of the database)
	JDBC api thorws SQLException which is a checked exception , Hibernate throws JDBCException which is un-ckecked exception.
	---> different states of entity Bean in HIbernate (transient, Persistent, Detached)
	--->
	---> hibernate criteria :
		criteria API is for retrieving Entities by composing Criterion Objects ,using criteria API we can place varibale number of condiitons on ResuktSet to get desired data by testing the ResultSet data againt all criterions.
		for ex. 
			List<cat> cats = session.createCriteria(Cat.class).add(Restrictions.like("name","IZ%")).add(Restrictions.gt("weight",new Float(minWeight))).addOrder(Order.asc("age")).list();
				methods names in Creteria API are self-explanatory.
	---> @Entity vs @Embeddeble
			Classes annotated as @Entity has independent existence in DB and have identities(IDs), while @Embeddeble classes are doesn't have independent existence ,its instances are stored as intrinsic part of owning Entity and share the identity of Entity, such as Employee and Address . Employee is an entity but Address in Embeddeble entity as it can not exist without Employee.
			
			Embeddable classes are used to represent the state of an entity but don’t have a persistent identity of their own, unlike entity classes. Instances of an embeddable class share the identity of the entity that owns it. Embeddable classes exist only as the state of another entity. An entity may have single-valued or collection-valued embeddable class attributes.
			
				@Embeddeble
				public class ZipCode{
					String zip;
					String plusFour;
				}
				 
				@Entity 
				public class Address{
					@Id
					Long id;
					@Embedded //not required actually
					ZipCode zip;
				}
	---> @Transactional
			annotation attributes -: readOnly:true/false, transactionPropagation :../.., isolation:read_committed/read_uncommitted/repeatable_read
	---> @OneToMany and @ManyToOne
			@OneToMany(mappedBy="forignkey_field_name_not_table_column_name",fetch=FetchType.EAGER,cascade=CascadeType.ALL)
			
			@ManyToOne
			@JoinColumn(name="forignKey_column_name")
			Object forignkey_field_name_not_table_column_name;
			
			Entity with foreign key is the owniner of the relationship.
	---> LazyInitializationException 
			
	---> HQL Joins:
			inner join, left outer join, right outer join, join fetch=?
---> SCSS : (Sassy CSS)
	1. $ to set varibales
	2. mixins let us group css declarations at one place and use them elsewhere. Mixins can accept argument and make use of that 	,for ex.
			@mixin border-radius($radius) { //declaring mixin with name border-radius which takes radius as argument
				-webkit-border-radius: $radius;
				-moz-border-radius: $radius;
				-ms-border-radius: $radius;
				border-radius: $radius;
			}

			.box { @include border-radius(10px); } //using mixin by passing the argument
	3. @extend is most important feature of scss , its lets you share css properties from one selector to other , for ex,
				.message {
				  border: 1px solid #ccc;
				  padding: 10px;
				  color: #333;
				}

				.success {
				  @extend .message;
				  border-color: green;
				}

				.error {
				  @extend .message;
				  border-color: red;
				}
	4. @include, @each, @if ......
	5. ampersand(&) in SCSS is used as parent selector which is missing in plain css,
		ex.	
			.parent{			compiles-to		.parent.child{
				&.child{		===========>	}				
				
				}
			}
		
---> $httpParamSerializer
	
---> button [type='submit' type='button']
	button type="submit" is by default even if you dont specify anything in type attribute on button element. type="button" has no default behavior
	
---> pseudo classes and pleudo elements
	pseudo elemnts or classes are those which we can access using DOM interface.
	:focus :link -> pseudo class
	::placeholder ::after -> pseudo element
---> Spring security
	architecture of spring security, User storage, client integration, passwords, customizing/overriding , remember me functionality, anonymous services , Authorization with expression, Access control list (ACLs), digest authenticaation for web services
	Authorization with expression is a recent addition ot spring security which help easing integraation with current systems.
---> Factory Pattern
	class FilterFactory (returns Filter instances on basis of FilterOperator like EQUAL, NOT_EQUAL, LESS_THAN, CONTAINS_STRING etc)
		-EqualToFilter implements Filter
			-
		-ContainsStringFilter implements Filter 
	interface Filter
		-isMatch()
---> $evalAsync 
	The asyncEval is after the DOM construction but before the browser renders.I believe that is the time you want to attach the jquery plugins. otherwise you will have flicker. if you really want to do after the browser render you can do $defer(fn, 0);
	
	https://github.com/angular/angular.js/issues/734#issuecomment-3657272/#

---> make tbody scrollable with fixed theader
		help https://bootsnipp.com/snippets/jvPA9
		
---> SET vs SELECT in SQL SERVER

		1. SET is the ANSI standard for variable assignment, SELECT is not.
		2. SET can only assign one variable at a time, SELECT can make multiple assignments at once.
		3. If assigning from a query, SET can only assign a scalar value. If the query returns multiple values/rows then SET will raise an error. SELECT will assign one of the values to the variable and hide the fact that multiple values were returned (so you'd likely never know why something was going wrong elsewhere - have fun troubleshooting that one)
		4. When assigning from a query if there is no value returned then SET will assign NULL, where SELECT will not make the assignment at all (so the variable will not be changed from its previous value)
		5. As far as speed differences - there are no direct differences between SET and SELECT. However SELECT's ability to make multiple assignments in one shot does give it a slight speed advantage over SET.
---> ng-attr-id, ng-attr-name, ng-attr-for 
		dynamic attributes in agularjs
---> Spring Security Annotation used in CL
	@permitAll -> can use with method annotated with @path , all request are allowed on that path 
	@RolesAllowed -> 
	---> pluralsight course
		->multiple <mvn:resources/> can be used in a single spring context configuration file.
		-> #ContentNegotiatingViewResolver# in Spring and its use ??
		-> spring i18n beans such as #SessionLocaleResolver#(?), #ResourceBundleMessageSource#(?), #LocaleChangeInterceptor#(?)
		-> lots of authencition in done using LDAP or active directory server for the authentication store
		-> authorization always follow authentication, first me make sure you ae who you are caiming to be and then authoriza them to access resources
		-> jars 
			spring-security-web	(contains web enabled security configurations )
			spring-security-config (contains general security configuration)
			commons-logging (just a facade for tying up with underlying logging mechanism)
		-> addded DelegatingFilterProxy filter in web.xml and mapped to /*
		-> added ContextLoaderListener and sprecified a context param 'security-config-location' with value 'WEB-INF/security-config.xml' which is used by ContextLoaderListener
		->ContextLoaderListener class bootstraps spring security context when application's context is loaded and DelegatingFilterProxy routes all the requests through spring security so that they can be evaluated in security configuration
		-> add a spring-secirity.xml file (keeping separate file for security configurations for separation of concerns)
			-> added a <http> tag and enabled auto-config which probably serves default lgin page when user is not authorised access a resource
			-> added <authentication-manager><authentication-provider><user-service>, for in-memory user authentication, define users and theirs passwords with their roles 
			-> as spring-security context is loaded when application contexts loads so in memory authentication is not feasible for production like applications as adding/or removing user would require re-deployment of application.
			this was simplest spring security configuration
		--> Now we will authenticate user by using database ,
				-> for that first we need to install a database, i used mysql 5.xml
				-> create two tables 
					1. User table - stores user name and passwords (and one extra 'enabled' column)
					2. Authorities table - stores rights for a given user 
		--> Now for data base conection and information retrieval we will ad some jars like mysql-connector jar and spring-jdbc jar.	
		-->	user details and authorities are stored in data base , we will configure a DataSource (DriverClassName, url,username,password) for database connection and a another JdbcDaoImpl bean which retrieves user details from database for authentication in security-config.xml file and modify our <authentication-provider> to use JdbcDaoImpl for user details authentication instead of in-memory authentication.
						<authentication-provider user-service-ref="id_of_JdbcDaoImpl_bean">
						or
			we can get rid of that JdbcDaoImpl bean, like below 	
					<authentication-provider>
						<jdbc-user-service data-source-ref="id_of_dataSource_bean">
					</authentication-provider>
---> Singleton pattern

		1. make constructor private to prevent manual instatiation 
		2. add a static method to return the instance of the singleton class.
			-> lazy isntantiation 
				instantiate only when getInstance() method is called
			-> Eager Instantiation
				instantiate at the time of class loading, instantiate at instance variable level
				
		if we are instantiating the singleton class insise a staic method of singleton class (say getInstance()) then its called lazy loading , otherwise if we are instatiation the class at isntance variable level then its called eager loading as instantiation is done at the time of class loading so even if user doen't use it the class will get instantiated.
			#Bill Plaugh# implementation of Singleton pattern by using a static inner class inside the singleton class
			#Joshua Bloch# implementation of Singleton pattern using Enums (overcome access via reflection)
---> Enum 
	its better if enum has private constructor as user can not invoke enum's constructor.The private constructor of enum will be invoked for each value to initialize the enum. 
		accessed a private member of a enum from outside the enum, NoteType.SOME_NOTE.noteType , here noteType is private to enum NoteType !!
			it happened because my enum was nested inside annother class, and in java you can always access private members of a nested types from containing type.
			
---> Getting Logged-in user details from ThreadContext(project specific class not part of JDK) ?? -: 

---> Jackson Deserialization(unmarshalling|from json to java) Annotations
	#@JsonCreator# (usually used with @JsonProperty to specify peroperty name or order)
		It’s very helpful when we need to deserialize some JSON that doesn’t exactly match the target entity we need to get.
	#@JsonValue#  

---> Mapping sql query parameters with enum :
	for ex, 	jdbcTemplate.update("SP_name :empId :empRole");
			empRole in our entity class is enum type
		Generally we use BeanPropertySqlParameterSource(entity) class to map sql query paramters with entity properties, 
		in our case, we can call	
			beanPropertySqlParametreSource.registerSqlType("empRole", Types.VARCHAR)
		to tell jdbcTemplate to map empRole as varchar is sql query paramter.
		i think enum should override toString() to make it work.not sure though
			