---> Debugging Skills
	A lot of people focus on tools and languages and frameworks for debugging but there are some meta-techniques which, if you practice, are really helpful in fixing bugs in lesser amount of time.
	Languages may come and go and so will IDEs and debuggers, but the ability to discern under which rock your bug is hiding is one that will stay with you forever.
	But one can not deny the amount of ease IDEs and tools add to our debugging.Knowledge of IDE debuggers is very important IMHO.
	"IF YOU HAVE BEEN LOOKING FOR A BUG FOR A RELATIVELY LONG TIME AND CAN'T FIND IT THEN YOU ARE LOOKING IN WRONG PLACE."
	Here are a few way shared by various developpers using which one can improve his/her debugging :
	1.Be disciplined. Debugging is a process, said one developer, not a series of random events. Don't randomly tweak knobs; follow the code's execution process. Just like fixing a lawnmower, he said. Does part A get the input it needs? How about the output? If that's OK, move on.
	
	2.To improve your skills, debug other people's code rather than your own. It will be easier to see the faults in the other person's assumptions than it is to see your own. You might do this as part of a cross-peer code review and cross-peer debugging. You will develop the ability to recognize the common causes of defects more quickly, promised one developer, and teach you to recognize (and abandon) your own bad development practices.
	
	3.Pretend you're the compiler. Find and correct as many errors as you can before pressing the Compile button. While most modern IDEs include integrated debuggers (like Visual Studio's Intellisense), you'll learn less from their automation than you will from consciously examining the process. (The same way you'll never learn to spell correctly by relying on a spell checker to do all the work.)
	
	4.Learn to fix bugs as early in the development process as you can. That might mean something formalized, such as test-driven development. That also means devoting time to debugging your design instead of barreling into coding.
	
	5.Debugging is easiest when you can hold the whole system in your head. Don't make the mistake of focusing in on only one part of an application. Pay attention to the interrelationships between modules. Read the code at multiple levels of abstraction, advised one programmer. "Finding the bug is the hardest part, and it takes clear understanding of what multiple pieces of the code are doing," she said.
	
	6.(my favoruit) Part of the same bit of advice, I think, is someone else's suggestion: gain a good understanding of the system one level down from what you are working on. "If you are debugging a system level C program, it helps to know some assembly and something about the OS," explained a system software lead engineer. "If you are debugging a J2EE app, it helps to know something about Java threads, RMI and GC." In many cases, he pointed out, error messages come from that one-level-down. "If you can understand what that means, it will help you figure out what is going wrong at your level of abstraction," he explained.

---> Rule Techonology :
Drools, Rule Engine..

---> Spring AOP :
	Cross Curring Concerns 
		The majority of the aplications we design will contain common functionality that spans layers and tiers.This functionality typically supports operations such authentication, authorization, caching, communication, exception management, Logging, instrumentation and validation.Such functionlaity is generally described as cross-cutting concern because it affects the entire application and should be centralized in one location in the code where possible.For example, If code that generates log entries and writes to the application logs is scattered throughout your layers and tiers, and the requirement related to these concerns change (such as logging to different location), you may have to update the relevant code throughout the entire system.Instead, If you centralize the logging code, you can chnage the behaviour bychanging the code in the just one location.
		
		In Spring a pointcut expression is used to determine whether advice needs to be executed or not 
			for ex, 	
				@PointCut("within(com.journaldev.spring.service.*)")
			sp there  are chances that these advices may get applied to some beans where its not intended.
			Thats why we create a custome annotation and annotae the method where we want the advice to be applied.
				pulic @interface Loggable{
				
				}
				
				@Aspect 
				public class EmployeeAnnotationAspect{
					@Before("@annotation(com.journaldev.spring.aspect.Loggable)")
					public void myAdvice(){
						System.out.println("executing my advice");
					}
				}
	
---> Spring fundamentals :



---> SQL replace NULL with empty String
	There are two ways to replace NULL with blank values in SQL Server, function ISNULL() and COALESCE()

---> Unable to install a breakpoint in (Eclipse debug mode error):
	configure build path- java compiler- add line number attribute
	
--->Checklist:
	1. Angular clean code 
	2. An Angular JS playbook
	3. Mockups (Ln bulletin)
	4. Spring boot 
	5. Drools (low priority)
	6. uib-modal dissection
	7. font-awesome
	8. token based vs cookie based authentication ,JSON Web Tokens (JWT) https://auth0.com/blog/cookies-vs-tokens-definitive-guide/
	9. NgModel Controller
	10. Configurable directives using Providers, by supplying configuration options before directive is instantiated
	11. Decorators to decorate services before use
CK:
	1. Angular UI router States
	2. Directives 
	3.	

---> Organizing multi-module maven project in eclipse project explorer (show child modules as child nodes):
	windows->Preferences-> Maven->Hide foders of physically nested modules and then re-import
				or 
	configure working sets 
	
---> <pluginManagement> vs <plugin> maven :
	Plugin configuration can be configured to be inherited by child POMs( or child modules) by using <pluginManagement/>.Plugin Configration added inside <pluginManagement/> doesn't apply to the POM (or project) it is defined in rather its intended for child POMs or projects.
	from child POMs you need to reference this parent plugin configuration to inherit the configuration, moreover child plugins can override parent pluginManagement definintion.
		
---> Combining Configuration Styles in Using Spring 4 (xml+java)
		http://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch06.html
		
---> Advantage and disadvantages of using XML config vs annotation
	XML configuration can be shared amaong different programming environments but not annotations
	annotations are attached to artifact they describe, thats a 'pro' point of annaotation
	
---> Unit testing Private methods:
	1.#Using Bytecode manipulator framework like PowerMock with mockito#
	2.By refactoring by changing private access modifier to default 
		as test classes are placed in same package yet in different folder(src/main/test)
			src/main/java
				com.infosys.fingerprintscanner.scanner
			src/test/java
				com.infosys.fingerprintscanner.scanner
				
---> Differential backup fo database in SqlServer
	A differential backup is based on the most recent, previous full data backup. A differential backup captures only the data that has changed since that full backup.
	
---> Precision vs Scale
	Numeric precision refers to the maximum number of digits that are present in the number.

	ie 1234567.89 has a precision of 9

	Numeric scale refers to the maximum number of decimal places

	ie 123456.789 has a scale of 3

	Thus the maximum allowed value for decimal(5,2) is 999.99
	
---> Running tests for a particular class mvn command
	mvn -Dtest=TstClassName test
	mvn -Dtest=TestClassName#testMethod# test

---> Spring Annotayions for configuration :
	@Configuration : 
	@EnableAutoConfiguration : 
		configures application based on the classes present on class path such as if Spring data JPA present of the class path the spring will register a entity manager factory bean if the user has not done so. As user's configurations override auto configurations. Any configuration added by this annotation which is not relevant can be exculeded using exclude property on the annotations	
			@EnableAutoConfiguration(exclude = { MetricFilterAutoConfiguration.class, MetricRepositoryAutoConfiguration.class })
					which excludes #actuator# configuration ;
					#Actuator# endpoints allow you to monitor and interact with your application. Spring Boot includes a number of built-in endpoints and you can also add your own. For example the health endpoint provides basic application health information.
	@SpringBootApplication :
		
--->HashMap(bucket) vs TreeMap(Red-black tree) vs LinkedHashMap(double bucket) :

	All three classes implement the Map interface and offer mostly the same functionality. The most important difference is the order in which iteration through the entries will happen:

	HashMap makes absolutely no guarantees about the iteration order. It can (and will) even change completely when new elements are added.
	TreeMap will iterate according to the "natural ordering" of the keys according to their compareTo() method (or an externally supplied Comparator). Additionally, it implements the SortedMap interface, which contains methods that depend on this sort order.
	LinkedHashMap will iterate in the order in which the entries were put into the map
			╔══════════════╦═════════════════════╦═══════════════════╦═════════════════════╗
			║   Property   ║       HashMap       ║      TreeMap      ║     LinkedHashMap   ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║  no guarantee order ║ sorted according  ║                     ║
			║   Order      ║ will remain constant║ to the natural    ║    insertion-order  ║
			║              ║      over time      ║    ordering       ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║  Get/put     ║                     ║                   ║                     ║
			║   remove     ║         O(1)        ║      O(log(n))    ║         O(1)        ║
			║ containsKey  ║                     ║                   ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║                     ║   NavigableMap    ║                     ║
			║  Interfaces  ║         Map         ║       Map         ║         Map         ║
			║              ║                     ║    SortedMap      ║                     ║
			╠══════════════╬═════════════════════╬═══════════════════╬═════════════════════╣
			║              ║                     ║                   ║                     ║
			║     Null     ║       allowed       ║    only values    ║       allowed       ║
			║ values/keys  ║                     ║                   ║                     ║
			╠══════════════╬═════════════════════╩═══════════════════╩═════════════════════╣
			║              ║   Fail-fast behavior of an iterator cannot be guaranteed      ║
			║   Fail-fast  ║ impossible to make any hard guarantees in the presence of     ║
			║   behavior   ║           unsynchronized concurrent modification              ║
			╠══════════════╬═════════════════════╦═══════════════════╦═════════════════════╣
			║              ║                     ║                   ║                     ║
			║Implementation║      buckets        ║   Red-Black Tree  ║    double-linked    ║
			║              ║                     ║                   ║       buckets       ║
			╠══════════════╬═════════════════════╩═══════════════════╩═════════════════════╣
			║      Is      ║                                                               ║
			║ synchronized ║              implementation is not synchronized               ║
			╚══════════════╩═══════════════════════════════════════════════════════════════╝
			workFlowActionMap is stored using LinkedHashMap in current project.
--->Doubly linked list:
	in singly linked list nodes have pointer to next node, so its not feasible to traverse a singly linked list backwards . in Doubly lined list nodes have pointers to next and previous both nodes hence backward traversing is possible. LinkedHashMap uses doubly linked list with bucket data structure.
--->AVL trees and Red Black Trees :
	in non-hight balanced Binary search tree the time complexity of searching is O(h) where is h is Height of the tree, if the hight of binary search tree is balanced with each insertion and removal of the nodes fro the BST then time complexity becomes O(log n) where n is number of nodes.AVL trees are a kind BSTs.AVL trees and Red-Black trees are hight balanced trees.In AVL trees the Balance Facoctor must not exceed 1.Balance Factor is Height of LeftSubtree - height of Right Subtree.If after any insertion/removal of a node from AVL tree makes Balance factor to 1 then the tree/subtree is rotated to make it hight balanced.
	
---> Binary Heap:
	A Binary is a complete tree (in which all levels are completely filled) except for last level and the last level has all the keys as lef as possible.This property of Binary heap make them suitable to pe stored in array.A bianry Heap is either min-heap or max-heap.
	Max-heap parent key is greater than both child keys and this is true for recursively all its subtrees and same goes with Min-heap.
	Binary Heap are very usefull in implementing efficient prority queues which are used for job scheduling processes in OS.Priority queues are also used in Dijkastr's and Prim's Graph algos.
---> Preventing CSS inheritance :
	in CSS there is not parent selector so far so you have to use child selctors to override styles of parent element.
	Or you can write selectors with high specificity so that styling does't cascade to unwanted elements.
	eventually Cascading is sort of the whole point of Cascading Style Sheets, hence the name.
---> hibernate Revisit :
	proxy objects for lazy loading 
	how JDBC does transacton management ? Hibernate makes Transaction Management very easy for developer.
		things involved in JDBC transaction and rollback(setting autoCommit to false before executing JDBC queries and then calling commit() manually after query executions, setting savePoints to rollback transaction to a specific state of the database)
	JDBC api thorws SQLException which is a checked exception , Hibernate throws JDBCException which is un-ckecked exception.
	---> different states of entity Bean in HIbernate (transient, Persistent, Detached)
	--->
	---> hibernate criteria :
		criteria API is for retrieving Entities by composing Criterion Objects ,using criteria API we can place varibale number of condiitons on ResuktSet to get desired data by testing the ResultSet data againt all criterions.
		for ex. 
			List<cat> cats = session.createCriteria(Cat.class).add(Restrictions.like("name","IZ%")).add(Restrictions.gt("weight",new Float(minWeight))).addOrder(Order.asc("age")).list();
				methods names in Creteria API are self-explanatory.
	---> @Entity vs @Embeddeble
			Classes annotated as @Entity has independent existence in DB and have identities(IDs), while @Embeddeble classes are doesn't have independent existence ,its instances are stored as intrinsic part of owning Entity and share the identity of Entity, such as Employee and Address . Employee is an entity but Address in Embeddeble entity as it can not exist without Employee.
			
			Embeddable classes are used to represent the state of an entity but don’t have a persistent identity of their own, unlike entity classes. Instances of an embeddable class share the identity of the entity that owns it. Embeddable classes exist only as the state of another entity. An entity may have single-valued or collection-valued embeddable class attributes.
			
				@Embeddeble
				public class ZipCode{
					String zip;
					String plusFour;
				}
				 
				@Entity 
				public class Address{
					@Id
					Long id;
					@Embedded //not required actually
					ZipCode zip;
				}
	---> @Transactional
			annotation attributes -: readOnly:true/false, transactionPropagation :../.., isolation:read_committed/read_uncommitted/repeatable_read
			
			---> @Transactional(propagation=Propagation.REQUIRED)
						If you need a laymans explanation of the use beyond that provided in the Spring Docs
						Consider this code...
							class Service {
								@Transactional(propagation=Propagation.REQUIRED)
								public void doSomething() {
									// access a database using a DAO
								}
							}
							When doSomething() is called it knows it has to start a Transaction on the database before executing. If the caller of this method has already started a Transaction then this method will use that same physical Transaction on the current database connection.
							This @Transactional annotation provides a means of telling your code when it executes that it must have a Transaction. It will not run without one, so you can make this assumption in your code that you wont be left with incomplete data in your database, or have to clean something up if an exception occurs.
	---> @OneToMany and @ManyToOne
			@OneToMany(mappedBy="forignkey_field_name_not_table_column_name",fetch=FetchType.EAGER,cascade=CascadeType.ALL)
			
			@ManyToOne
			@JoinColumn(name="forignKey_column_name")
			Object forignkey_field_name_not_table_column_name;
			
			Entity with foreign key is the owniner of the relationship.
	---> LazyInitializationException 
			
	---> HQL Joins:
			inner join, left outer join, right outer join, join fetch=?
---> SCSS : (Sassy CSS)
	1. $ to set varibales
	2. mixins let us group css declarations at one place and use them elsewhere. Mixins can accept argument and make use of that 	,for ex.
			@mixin border-radius($radius) { //declaring mixin with name border-radius which takes radius as argument
				-webkit-border-radius: $radius;
				-moz-border-radius: $radius;
				-ms-border-radius: $radius;
				border-radius: $radius;
			}

			.box { @include border-radius(10px); } //using mixin by passing the argument
	3. @extend is most important feature of scss , its lets you share css properties from one selector to other , for ex,
				.message {
				  border: 1px solid #ccc;
				  padding: 10px;
				  color: #333;
				}

				.success {
				  @extend .message;
				  border-color: green;
				}

				.error {
				  @extend .message;
				  border-color: red;
				}
	4. @include, @each, @if ......
	5. ampersand(&) in SCSS is used as parent selector which is missing in plain css,
		ex.	
			.parent{			compiles-to		.parent.child{
				&.child{		===========>	}				
				
				}
			}
		
---> $httpParamSerializer
	
---> button [type='submit' type='button']
	button type="submit" is by default even if you dont specify anything in type attribute on button element. type="button" has no default behavior
	
---> pseudo classes and pleudo elements
	pseudo elemnts or classes are those which we can access using DOM interface.
	:focus :link -> pseudo class
	::placeholder ::after -> pseudo element
---> Spring security
	architecture of spring security, User storage, client integration, passwords, customizing/overriding , remember me functionality, anonymous services , Authorization with expression, Access control list (ACLs), digest authenticaation for web services
	Authorization with expression is a recent addition ot spring security which help easing integraation with current systems.
---> Factory Pattern
	class FilterFactory (returns Filter instances on basis of FilterOperator like EQUAL, NOT_EQUAL, LESS_THAN, CONTAINS_STRING etc)
		-EqualToFilter implements Filter
			-
		-ContainsStringFilter implements Filter 
	interface Filter
		-isMatch()
---> $evalAsync 
	The asyncEval is after the DOM construction but before the browser renders.I believe that is the time you want to attach the jquery plugins. otherwise you will have flicker. if you really want to do after the browser render you can do $defer(fn, 0);
	
	https://github.com/angular/angular.js/issues/734#issuecomment-3657272/#

---> make tbody scrollable with fixed theader
		help https://bootsnipp.com/snippets/jvPA9
		
---> SET vs SELECT in SQL SERVER

		1. SET is the ANSI standard for variable assignment, SELECT is not.
		2. SET can only assign one variable at a time, SELECT can make multiple assignments at once.
		3. If assigning from a query, SET can only assign a scalar value. If the query returns multiple values/rows then SET will raise an error. SELECT will assign one of the values to the variable and hide the fact that multiple values were returned (so you'd likely never know why something was going wrong elsewhere - have fun troubleshooting that one)
		4. When assigning from a query if there is no value returned then SET will assign NULL, where SELECT will not make the assignment at all (so the variable will not be changed from its previous value)
		5. As far as speed differences - there are no direct differences between SET and SELECT. However SELECT's ability to make multiple assignments in one shot does give it a slight speed advantage over SET.
---> ng-attr-id, ng-attr-name, ng-attr-for 
		dynamic attributes in agularjs
---> Spring Security Annotation used in CL
	@permitAll -> can use with method annotated with @path , all request are allowed on that path 
	@RolesAllowed -> 
	---> pluralsight course
		->multiple <mvn:resources/> can be used in a single spring context configuration file.
		-> #ContentNegotiatingViewResolver# in Spring and its use ??
		-> spring i18n beans such as #SessionLocaleResolver#(?), #ResourceBundleMessageSource#(?), #LocaleChangeInterceptor#(?)
		-> lots of authencition in done using LDAP or active directory server for the authentication store
		-> authorization always follow authentication, first me make sure you ae who you are caiming to be and then authoriza them to access resources
		-> jars 
			spring-security-web	(contains web enabled security configurations )
			spring-security-config (contains general security configuration)
			commons-logging (just a facade for tying up with underlying logging mechanism)
		-> addded DelegatingFilterProxy filter in web.xml and mapped to /*
		-> added ContextLoaderListener and sprecified a context param 'security-config-location' with value 'WEB-INF/security-config.xml' which is used by ContextLoaderListener
		->ContextLoaderListener class bootstraps spring security context when application's context is loaded and DelegatingFilterProxy routes all the requests through spring security so that they can be evaluated in security configuration
		-> add a spring-secirity.xml file (keeping separate file for security configurations for separation of concerns)
			-> added a <http> tag and enabled auto-config which probably serves default lgin page when user is not authorised access a resource
			-> added <authentication-manager><authentication-provider><user-service>, for in-memory user authentication, define users and theirs passwords with their roles 
			-> as spring-security context is loaded when application contexts loads so in memory authentication is not feasible for production like applications as adding/or removing user would require re-deployment of application.
			this was simplest spring security configuration
		--> Now we will authenticate user by using database ,
				-> for that first we need to install a database, i used mysql 5.xml
				-> create two tables 
					1. User table - stores user name and passwords (and one extra 'enabled' column)
					2. Authorities table - stores rights for a given user 
		--> Now for data base conection and information retrieval we will ad some jars like mysql-connector jar and spring-jdbc jar.	
		-->	user details and authorities are stored in data base , we will configure a DataSource (DriverClassName, url,username,password) for database connection and a another JdbcDaoImpl bean which retrieves user details from database for authentication in security-config.xml file and modify our <authentication-provider> to use JdbcDaoImpl for user details authentication instead of in-memory authentication.
						<authentication-provider user-service-ref="id_of_JdbcDaoImpl_bean">
						or
			we can get rid of that JdbcDaoImpl bean, like below 	
					<authentication-provider>
						<jdbc-user-service data-source-ref="id_of_dataSource_bean">
					</authentication-provider>
---> Singleton pattern

		1. make constructor private to prevent manual instatiation 
		2. add a static method to return the instance of the singleton class.
			-> lazy isntantiation 
				instantiate only when getInstance() method is called
			-> Eager Instantiation
				instantiate at the time of class loading, instantiate at instance variable level
				
		if we are instantiating the singleton class insise a staic method of singleton class (say getInstance()) then its called lazy loading , otherwise if we are instatiation the class at isntance variable level then its called eager loading as instantiation is done at the time of class loading so even if user doen't use it the class will get instantiated.
			#Bill Plaugh# implementation of Singleton pattern by using a static inner class inside the singleton class
				public class SingletonClass{
					private static class SingletonHelper{
						public static final SingletonClass INSTANCE = new SingletonHelper();
					}
					public static SIngletonClass getInstance(){
						return SingletonHelper.INSTANCE;
					}
				}
				There's nothing really special about the nested class, it just allows the outer class to be used without immediately constructing the singleton object. Almost certainly this is entirely pointless, but it seems to please some people.
			#Joshua Bloch# implementation of Singleton pattern using Enums (overcome access via reflection)
---> Enum 
	its better if enum has private constructor as user can not invoke enum's constructor.The private constructor of enum will be invoked for each value to initialize the enum. 
		accessed a private member of a enum from outside the enum, NoteType.SOME_NOTE.noteType , here noteType is private to enum NoteType !!
			it happened because my enum was nested inside annother class, and in java you can always access private members of a nested types from containing type.
			
---> Getting Logged-in user details from ThreadContext(project specific class not part of JDK) ?? -: 

---> Jackson Deserialization(unmarshalling|from json to java) Annotations
	#@JsonCreator# (usually used with #@JsonProperty# to specify peroperty name or order, mostly applied at constructor level)
		It’s very helpful when we need to deserialize some JSON that doesn’t exactly match the target entity we need to get.
		 for ex enum to String
	#@JsonValue# used on a method which tells how this instance will be serailized (from java to json)
		public enum TypeEnumWithValue {
			TYPE1(1, "Type A"), TYPE2(2, "Type 2");
		 
			private Integer id;
			private String name;
		 
			@JsonValue
			public String getName() {
				return name;
			}
		}
	#@JsonInclude# mostly used at class (model class) level to  exclude empty/null/default values
			@JsonInclude(JsonInclude.Include.NON_NULL) to exclude null values from serialization
	#@JsonIgnoreProperties#
		can be used to suppress serialization of properties during serialization 
			@JsonIgnoreProperties({'internalId', 'secretKey'})
		can be used to ignore processing of JSON properties during deserialization  
			@JsonIgnoreProperties(ignoreUnknown = true)
---> Mapping sql query parameters with enum :
	for ex, 	jdbcTemplate.update("SP_name :empId :empRole");
			empRole in our entity class is enum type
		Generally we use BeanPropertySqlParameterSource(entity) class to map sql query paramters with entity properties, 
		in our case, we can call	
			beanPropertySqlParametreSource.registerSqlType("empRole", Types.VARCHAR)
		to tell jdbcTemplate to map empRole as varchar is sql query paramter.
		i think enum should override toString() to make it work.not sure though
---> Java 8 collection streams and Stream Collectors :
		Concating two Lists 
			Stream.concat(list_one.stream(), list_two.stream()).collect(Collector.toList())
---> Java 8 method references :
		You use lambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it's often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.
			Arrays.sort(rosterAsArray,
				(a, b) -> Person.compareByAge(a, b)
			);
			is same as 
			Arrays.sort(rosterAsArray,
				(a, b) -> Person::compareByAge)
			);
			assuming Person class/enum has compareByAge method inside it.
---> Angular One way bind Syntax (Todd Motto)
		<p>
		  {{ ::vm.user }}
		</p>
		<div ng-if="::vm.user.loggedIn"></div>
		<div ng-class="::{ loggedIn: vm.user.loggedIn }"></div>
		<ul>
		  <li ng-repeat="user in ::vm.users"></li>
		</ul>
---> Spring JDBCTemplate batchUpdate & Simple JDBC batch query processing:
			
---> Quartz Job Scheduler Java (other job scheduling lib- Obsidian Scheduler):

---> $watch vs $observer
		$observer function is present in Attribute object and it can be used inside a directive only.Use $observer only when you need to watch/observer a DOM attribute which contains inerpolation{{}}. ex <div attr1 = "name {{name}}">

---> Self Join, JOIN FETCH in Hibernate 
		---> JOIN FETCH
		1. "FROM Employee emp JOIN emp.department dep" vs 2. "FROM Employee emp JOIN FETCH emp.department dep"
		In this two queries, you are using JOIN to query all employees that have at least one department associated.

		But, the difference is: in the first query you are returning only the Employes for the Hibernate. In the second query, you are returning the Employes and all Departments associated.

		So, if you use the second query, you will not need to do a new query to hit the database again to see the Departments of each Employee.

		You can use the second query when you are sure that you will need the Department of each Employee. If you not need the Department, use the first query.

		If you don't use fetch and the Departments continue to be returned, is because your mapping between Employee and Department (a @OneToMany) are setted with FetchType.EAGER
		Remember that all mapping #*ToOne# (@ManyToOne and @OneToOne) are EAGER by default.
---> Internal Working of HashSet and HashMap
		HashSet uses HashMap internally to store it’s objects. Whenever you create a HashSet object, one HashMap object associated with it is also created. This HashMap object is used to store the elements you enter in the HashSet. The elements you add into HashSet are stored as keys of this HashMap object. The value associated with those keys will be a constant.
		
		Every constructor of HashSet class internally creates one HashMap object
		
		it actually creates an entry in the internally backing HashMap object with element you have specified as it’s key and constant called “PRESENT” as it’s value

---> @Conroller vs @RestController,
		@Controller is used to mark classes as Spring MVC Controller.
		@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations (see: Javadoc)
		
		Spring’s annotation based MVC framework simplifies the process of creating RESTful web services. The key difference between a traditional Spring MVC controller and the RESTful web service controller is the way the HTTP response body is created. While the traditional MVC controller relies on the View technology, the RESTful web service controller simply returns the object and the object data is written directly to the HTTP response as JSON/XML

---> Dirty Read vs Phantom Read, Non-Repeatable Read,
		1.Dirty Read 
			Dirty read occurs wherein one transaction is changing the tuple/record, and a second transaction can read this tuple/record before the original change has been committed or rolled back. This is known as a dirty read scenario because there is always the possibility that the first transaction may rollback the change, resulting in the second transaction having read an invalid value. 

			To understand it better,lets take a use case where on thread is viewing the record and other thread is updating the value of the record.Since the transaction isolation attribute is set to READ UNCOMMITTED.Second thread will be able to see the changes made by other thread.
		2. Phantom read	
			Phantom read occurs where in a transaction same query executes twice, and the second result set includes rows that weren't visible in the first result set. This situation is caused by another transaction inserting new rows between the execution of the two queries.
			To understand it better consider  a use case where one thread is inserting the data while other thread is reading the data in different transaction.Since reader thread has isolation attribute as READ COMMITTED,reader thread will see the new rows inserted when it queries again.
		3.Non-Repeatable Read	
			Non Repeatable Reads happen when in a same transaction same query yields different results. This happens when another transaction updates the data returned by other transaction.
			To understand it better lets take a use case where one thread is viewing the data and other thread is updating the data.Since isolation level is READ COMMITED,other thread will be able to view the updated changes.So in the same transaction,same query will yield different data.

---> @Transactional,

---> Stream Filters,

---> OSGi vs Maven,

---> Multithreading fundamentals,

---> Database fundamentals,

---> Stored Procedure vs Function,
		Functions are computed values and cannot perform permanent environmental changes to SQL Server (i.e. no INSERT or UPDATE statements allowed).

		A Function can be used inline in SQL Statements if it returns a scalar value or can be joined upon (ex. left join, inner join etc) if it returns a result set.
		The return value of a function can either be a scalar (single) value or a table (using Table variable).
		+---------------------------------+----------------------------------------+
		| Stored Procedure (SP)           | Function (UDF - User Defined           |
		|                                 | Function)                              |
		+---------------------------------+----------------------------------------+
		| SP can return zero , single or  | Function must return a single value    |
		| multiple values.                | (which may be a scalar or a table).    |
		+---------------------------------+----------------------------------------+
		| We can use transaction in SP.   | We can't use transaction in UDF.       |
		+---------------------------------+----------------------------------------+
		| SP can have input/output        | Only input parameter.                  |
		| parameter.                      |                                        |
		+---------------------------------+----------------------------------------+
		| We can call function from SP.   | We can't call SP from function.        |
		+---------------------------------+----------------------------------------+
		| We can't use SP in SELECT/      | We can use UDF in SELECT/ WHERE/       |
		| WHERE/ HAVING statement.        | HAVING statement.                      |
		+---------------------------------+----------------------------------------+
		| We can use exception handling   | We can't use Try-Catch block in UDF.   |
		| using Try-Catch block in SP.    |                                        |
		+---------------------------------+----------------------------------------+

---> LinkedList vs ArrayList
		LinkedList and ArrayList are two different implementations of the List interface. LinkedList implements it with a doubly-linked list. ArrayList implements it with a dynamically re-sizing array.
		
		LinkedList<E> allows for constant-time insertions or removals using iterators, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but finding a position in the list takes time proportional to the size of the list. Javadoc says "operations that index into the list will traverse the list from the beginning or the end, whichever is closer", so those methods are O(n/4) on average, though O(1) for index = 0.
		
		ArrayList<E>, on the other hand, allow fast random read access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap. Also, if you add more elements than the capacity of the underlying array, a new array (1.5 times the size) is allocated, and the old array is copied to the new one, so adding to an ArrayList is O(n) in the worst case but constant on average.

---> EntityManager vs SessionFactory 
	
	Prefer EntityManagerFactory and EntityManager. They are defined by the JPA standard.

	SessionFactory and Session are hibernate-specific. The EntityManager invokes the hibernate session under the hood. And if you need some specific features that are not available in the EntityManager, you can obtain the session by calling:

		Session session = entityManager.unwrap(Session.class);
	If you want, you can always get the Hibernate Session from the JPA EntityManager. Not vice-versa

---> Executor Service Example (With Callable and Future API) (and There is One More FutureTask for convenience)
	There are two ways of creating threads – one by extending the Thread class and other by creating a thread with a Runnable. However, one feature lacking in  Runnable is that we cannot make a thread return result when it terminates, i.e. when run() completes. For supporting this feature, the Callable interface is present in Java.
	---> Callable vs Runnable

		1. For implementing Runnable, the run() method needs to be implemented which does not return anything, while for a Callable, the call() method needs 	to be implemented which returns a result on completion. Note that a thread can’t be created with a Callable, it can only be created with a 			Runnable.
		2. Another difference is that the call() method can throw an exception whereas run() cannot.
	
	UtilityClass to read, update and save
	int totalTasks = number of iteration * number of threads
	initialize a CountDownLatch with totalTasks
	
		CountDownLatch signal = new CountDownLatch(totalTasks);
		
		ExecutorService executor = Executors.newFixedThreadPool(UtilityClass.getThreadCount());
		Runnable worker = new FileOperations(UtilityClass, signal);
		while (UtilityClass.getQueue().size() > 0) {
			executor.execute(worker);
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				throw new Exception(e);
			}
		}
		executor.shutdown();

		try {
			signal.await();
		} catch (InterruptedException e) {
			throw new Exception(e);
		}
		UtilityClass.printResult();
		
		thread 
		
		public class FileOperations implements Runnable {
			private CountDownLatch signal;
			private UtilityClass base;


			public FileOperations(UtilityClass base, CountDownLatch signal) {
				this.base = base;
				this.signal = signal;
			}

			//@Override
			public void run() {
				FileVO vo = base.getQueue().poll();
				if (vo != null && (vo.getIterations() - 1) > 0) {
					vo.setIterations(vo.getIterations() - 1);
					base.getQueue().add(vo);
				}
				if (vo != null) {
					base.calculateTime(vo);
					signal.countDown();
				}

			}
			}
			
		Model to work on 
			FileVO 
				fileName;
				 ByteArrayOutputStream baos;
				 int iterations;
			
---> SQL Server datatype datetime2(fractional seconds precision)
		Defines a date that is combined with a time of day that is based on 24-hour clock. datetime2 can be considered as an extension of the existing datetime type that has a larger date range, a larger default fractional precision, and optional user-specified precision
		
---> All About floats
		if a parent container has all the floating childs, the height of parent element would collapse to nothing.
		http://css-tricks.com/all-about-floats/
		
---> hardening 
		extra sprint to clear all technical debt of last sprints 
		
---> Strategy Pattern	
		encapsulate strategy (behaviour that changes )
---> Oopen/close principle (Object Oriented Pricipal)

---> package-info.java file		
		The package-info.java is a Java file that can be added to any Java source package.  Its purpose is to provide a home for package level documentation and package level annotations. Simply create the package-info.java file and add the package declaration that it relates to in the file.  In fact, the only thing the package-info.java file must contain is the package declaration.
		1. description and other related documentation for a package can be written up in the package-info.java
		2. package level annotations(An annotation with ElementType.PACKAGE as one of its targets)
---> Eclipse Subversive plugin For SVN features like Repo browsing and blame (annotation)

---> Request Headers 
	Cookie: 
		useListCache=F;
		selectedQuickSearchType=profiles;
		RESTAPISESSIONID=....,JSESSIONID=....; _ga=GA1.1.812133076.1498460543; _gid = GA!.1.*.*
	
	_ga and _gid google analytics related cookies.
	
---> SQL SERVER | SET NOCOUNT ON;
		stops the message that shows the count of the number of rows affected by a Transact-SQL statement or stored procedure.
		basically it prevents sending sql statment completion messages to the client for each statement in stored procedure and it provides significant performance boost because network traffic is greatly reduced.
		
---> XSS UNSAFE PATTERN :
		Pattern.compile("[^-+|/\\w,\\.\t ]")
		A safe string is one with word chars [a-zA-Z_0-9] or white space char [\s] or URL control chars [/=?&] or a dot(.).Percent signs are a risk because browser will interpret %27 as a single quite which can artificially truncate strings. 
		
---> Marker Interfaces and Its uses (TIAA interview)
		A marker interface must be empty and implementing it is meant to imply some special treatment of implementing class but it is incorrect that JVM or compiler would treat the object of the class differenty.#It has nothing to do with the compiler or the JVM#, if it was true then to write our own marker interface would require teaching compiler how to treat the object of the class implementing nw interface.
		
		---> How Annotations are better than Marker Interfaces?
			They let you achieve the same purpose of conveying metadata about the class to its consumers without creating a separate type for it. Annotations are more powerful, too, letting programmers pass more sophisticated information to classes that "consume" it.
			
			#One thing to keep in mind is that annotations were added to the language some years after the standard library was originally designed. If annotations had been in the language from the start, it is doubtful that Serializable would have been an interface, it probably would have been an annotation.#
---> Spring Security (Authentication Provider switch from LDAP to Database and vice versa)

---> Printing Java Object with no toString overriden -:
		Sysout(someObject) prints com.some.package.ClassName@*alphanumericString*
		Sysout(someObject.hashCode()) prints an integer 3210992
		convert 3210992 to hex and you will get *alphanumericString*
		
---> Creating Immutable classes
		declare as final (so that no extending allowed)
		declare instance fields private and final
		initialize instance variable in constructor
		return copy/clone of data from getter methods
		no setter methods
		
---> The JIT Compiler -:
		In the beginning a compiler was responsible for turning a high level language into machine instrcutions, which would then be linked by a linker to an executable (i.e. compiled all the code into machine language before the program is first run).
		
		then at one point in evolution of languages, compilers would compile a high-level language into an intermediate pdeudo-code ( like bytecode), which would then be interpreted by an interpreter to run your program.This eliminated the machine instructions generation and liknking to executable even before program is run and this allowed these languages to be protable to multiple operating systems and hardware platforms.

		Pascal was one of the first Java and C## are recent examples.
		A Just-In-Time compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, will compile the byte-code into the machine code instructions of the underlying running machine.
		
		Ideally the efficiency of running the bytecode will overcome the inefficiency of recompiling the program every time it runs.
		
---> Database Indexing and How does it help to speed up data retrieval :
		
---> Size of a reference variable in JAVA :
		on 32bit JVM its 32 bits on 64bit JVM its #32bit# but can be changed to 64bit using deactivating configuration for Compressed Ordinary Object Pointers (-XX:-UseCompressedOops).
---> SQL Server 'System Stored Procedure' -:
		to get a desciption of a table in oracle we used to call 'desc table_name', but in sql server there is no desc command.In sql server we use Systemm Stored Procedures for such functions , for ex,
					#exec sp_columns table_name# -> returns column information for a table
					#exec sp_help table_name# -> gives table definitions which includes (column information, any indexes on columns of the table, constraints on the table, which table is referencing this table as FK container etc.)
					#sp_executesql# -> 